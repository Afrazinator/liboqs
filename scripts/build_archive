#!/bin/bash

#Unarchive the library in their own directory 

cd  archive_temp
for c in `find . -name "*.a"`;do
  mkdir ${c}_1
  cp $c ${c}_1
  cd ${c}_1 
  ar x $c
  cd ..
done

#Find duplicate object files (by name) across all the algorithms and their
#implementations

objs=`find . -name "*.o" | awk  'BEGIN { FS = "/" } ; {print $3}'| sort`
array=()
oldobj='' 
for obj in $objs;do
  newobj=$obj
#  echo $newobj
  if [ ! -z "$oldobj" ];then
    if [ "$newobj" = "$oldobj" ];then
#      echo $newobj
#      echo $oldobj
      array+=' '
      array+=$oldobj
    fi
  fi
    oldobj=$newobj
done

dupes=`echo ${array[@]}|tr ' ' '\n'|uniq`
#echo $dupes

#Find unique object files by content (among files with duplicate names) across all the algorithms and their
#implementations

for dupe in $dupes;do
#  echo $dupe
  different=0
  oldobj1=''
  newobjs=`find . -name "$dupe"`
# echo $newobjs
  for newobj in $newobjs;do 
#   echo $newobj
    if [ ! -z "$oldobj1" ];then
      m1=`md5sum $newobj| awk '{print $1}'`
      m2=`md5sum $oldobj1 | awk '{print $1}'`
#     echo $m1
#     echo $m2
      if [ "$m1" != "$m2" ];then
        different=1
#       echo $m1
#       echo $m2
        unique_dup+=' '
        unique_dup+=$oldobj1
      fi
    fi
    oldobj1=$newobj
  done
  if [ $different -eq 1 ];then
    unique_dup+=' '
    unique_dup+=$oldobj1
  fi
done

#Make content-wise unique file namewise-unique too by appending a counter value.

unique_dupes=`echo ${unique_dup[@]}`
var=1
for unique_dup in ${unique_dupes};do
  unique=`echo ${unique_dup} | sed 's/\(.*\)\(.o\)/\1_'$var'\2/'`
# echo $unique
  mv ${unique_dup} $unique
  var=$((var+1))
done

#Aggregate all the updated object files in a new directory 

mkdir final_temp
objs=`find . -name "*.o"`
for obj in $objs;do
  cp -f $obj final_temp/
done

cd final_temp
ar cr liboqs.a *.o 
cp liboqs.a ../..
cd ../..

#Compile test_kem.c to collect linking errors for resolution later

gcc src/kem/test_kem.c liboqs.a -o test_kem  -O2 -std=c11 -Iinclude -I/usr/local/opt/openssl/include -Wno-unused-function -Werror -Wpedantic -Wall -Wextra  -L/usr/local/opt/openssl/lib -lcrypto -lm  >t 2>&1 

cat t | grep -v data | grep -v collect2| grep -v Warning > func
awk '{ printf "%s", $0; if (NR % 3 == 0) print ""; else printf " " }' func > func_merged

#Linking errors related to function name collision
#Below is used to get symbols and the corresponding object files where the
#errors are happening 

funcs_collision=$(cat func_merged | tr '(' ' ' | tr ')' ' '| tr -d ''\''' | tr -d '`' | tr -d ':'| awk '{print $2" "$13" "$5}')

cd archive_temp/final_temp


#Rename the symbols to prevent function name collision

var=1
first=
second=
third=
counter=1
for foo in ${funcs_collision};do
  first=$foo
  if [ $((var%3)) -eq 0 ];then
    objcopy --redefine-sym $first=${first}_$counter $third
    counter=$((counter+1))
    objcopy --redefine-sym $first=${first}_$counter $second
    counter=$((counter+1))
    #echo $third $second $first
  fi
  if [ $((var%3)) -eq 2 ];then
    third=$second
  fi
  second=$first
  var=$((var+1))
done

cd ../..

#Linking errors related to data section

data_collison=$(cat t | grep data |awk '{ printf "%s", $0; if (NR % 2 == 0) print ""; else printf " " }' |  tr '(' ' ' | tr ')' ' '| tr -d ''\''' | tr -d '`' | tr -d ':'| awk '{print $2" "$9" "$7}')


cd archive_temp/final_temp


#Rename the symbols to prevent data name collision

var=1
for foo in ${data_collison};do
  first=$foo
  if [ $((var%3)) -eq 0 ];then
    objcopy --redefine-sym $first=${first}_$counter $third
    counter=$((counter+1))
    objcopy --redefine-sym $first=${first}_$counter $second
    counter=$((counter+1))
    #echo $third $second $first
  fi
  if [ $((var%3)) -eq 2 ];then
    third=$second
  fi
  second=$first
  var=$((var+1))
done

#create archive and cleanup

rm -f liboqs.a
ar cr liboqs.a *.o 
cp liboqs.a ../..
cd ../..
rm -f t func func_merged




